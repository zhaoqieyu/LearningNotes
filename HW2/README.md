# 何謂 Heap Sort?
  * linked list的變形
  * tree的special case
  * 時間複雜度
    * Best Case：Ο(n log n)
    * Worst Case：Ο(n log n)　
    * Average Case：Ο(n log n)
    
# 何謂 Merge Sort?
  * 先將陣列平均分堆，直到只剩下一個元素，再進行同時排序排序
  * 時間複雜度
    * Best Case：Ο(n log n)
    * Worst Case：Ο(n log n)　
    * Average Case：Ο(n log n)

# Heap Sort & Merge Sort之比較
| item | content | heap_sort | merge_sort
| :---: | :---: | :---: | :---: 
1 | 中文 | **堆積**排序法 | **合併**排序法
2 | 結構 | 近似完全二元**樹** → 允許最底下那一層的節點可以不用完全填滿，又分**最大堆積**、**最小堆積** | **陣列**
3 | 做法 | **先把原本序列轉換成一棵樹**，再由**左邊到右邊**、**上層到下層**做比較，記得要**移除最上面(第一筆資料)的節點**  | 採用**分割、整合**的方式 → 將原本序列分割成兩個子序列，再分別用遞迴的方式排序，並丟入新的序列中，最後將這兩堆排好的資料合併在一起
4 | index的位置 | 用**公式**去推 → l=2*i+1 / r=2*i+2 | 用 **+** 去找下一個index
5 | 時間複雜度 | 最佳、最差及平均情況下 :**O(nlogn)** | n筆資料一般需要約log2n次處理，每次處理的時間複雜度為**O(n)** ，因此最佳、最差及平均情況皆為**O(nlogn)**
6 | 空間複雜度 | **O(1)** ：將list轉為heap，因此過程中**不會申請額外空間** | **O(n)** ：排序時需**要有額外的空間**來做處理，此空間與檔案大小相同
7 | 穩定度 | 不穩定 | 穩定
小結 | 難易度(自己覺得) | 覺得較難，因為樹的結構要去想**index的位置**，**index現在跑到哪**，常常會搞亂 | 寫起來比較簡單 
